{"version":3,"sources":["../../../src/crypto/verification/QRCode.js"],"names":["MATRIXTO_REGEXP","KEY_REGEXP","newQRCodeError","ShowQRCode","_done","url","_baseApis","getUserId","encodeURIComponent","deviceId","getDeviceEd25519Key","emit","Base","NAME","ScanQRCode","resolve","reject","done","cancel","code","match","keys","userId","params","split","map","x","decodeURIComponent","action","name","value","keyMatch","length","confirm","expected","actual","_verifyKeys","keyId","device","key","args"],"mappings":"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","file":"QRCode.js","sourcesContent":["/*\nCopyright 2018 New Vector Ltd\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * QR code key verification.\n * @module crypto/verification/QRCode\n */\n\nimport Base from \"./Base\";\nimport {\n    errorFactory,\n    newUserCancelledError,\n    newKeyMismatchError,\n    newUserMismatchError,\n} from './Error';\n\nconst MATRIXTO_REGEXP = /^(?:https?:\\/\\/)?(?:www\\.)?matrix\\.to\\/#\\/([#@!+][^?]+)\\?(.+)$/;\nconst KEY_REGEXP = /^key_([^:]+:.+)$/;\n\nconst newQRCodeError = errorFactory(\"m.qr_code.invalid\", \"Invalid QR code\");\n\n/**\n * @class crypto/verification/QRCode/ShowQRCode\n * @extends {module:crypto/verification/Base}\n */\nexport class ShowQRCode extends Base {\n    _doVerification() {\n        if (!this._done) {\n            const url = \"https://matrix.to/#/\" + this._baseApis.getUserId()\n                  + \"?device=\" + encodeURIComponent(this._baseApis.deviceId)\n                  + \"&action=verify&key_ed25519%3A\"\n                  + encodeURIComponent(this._baseApis.deviceId) + \"=\"\n                  + encodeURIComponent(this._baseApis.getDeviceEd25519Key());\n            this.emit(\"show_qr_code\", {\n                url: url,\n            });\n        }\n    }\n}\n\nShowQRCode.NAME = \"m.qr_code.show.v1\";\n\n/**\n * @class crypto/verification/QRCode/ScanQRCode\n * @extends {module:crypto/verification/Base}\n */\nexport class ScanQRCode extends Base {\n    static factory(...args) {\n        return new ScanQRCode(...args);\n    }\n\n    async _doVerification() {\n        const code = await new Promise((resolve, reject) => {\n            this.emit(\"scan\", {\n                done: resolve,\n                cancel: () => reject(newUserCancelledError()),\n            });\n        });\n\n        const match = code.match(MATRIXTO_REGEXP);\n        let deviceId;\n        const keys = {};\n        if (!match) {\n            throw newQRCodeError();\n        }\n        const userId = match[1];\n        const params = match[2].split(\"&\").map(\n            (x) => x.split(\"=\", 2).map(decodeURIComponent),\n        );\n        let action;\n        for (const [name, value] of params) {\n            if (name === \"device\") {\n                deviceId = value;\n            } else if (name === \"action\") {\n                action = value;\n            } else {\n                const keyMatch = name.match(KEY_REGEXP);\n                if (keyMatch) {\n                    keys[keyMatch[1]] = value;\n                }\n            }\n        }\n        if (!deviceId || action !== \"verify\" || Object.keys(keys).length === 0) {\n            throw newQRCodeError();\n        }\n\n        if (!this.userId) {\n            await new Promise((resolve, reject) => {\n                this.emit(\"confirm_user_id\", {\n                    userId: userId,\n                    confirm: resolve,\n                    cancel: () => reject(newUserMismatchError()),\n                });\n            });\n        } else if (this.userId !== userId) {\n            throw newUserMismatchError({\n                expected: this.userId,\n                actual: userId,\n            });\n        }\n\n        await this._verifyKeys(userId, keys, (keyId, device, key) => {\n            if (device.keys[keyId] !== key) {\n                throw newKeyMismatchError();\n            }\n        });\n    }\n}\n\nScanQRCode.NAME = \"m.qr_code.scan.v1\";\n"]}