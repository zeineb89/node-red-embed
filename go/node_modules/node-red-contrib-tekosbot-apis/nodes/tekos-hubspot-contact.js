module.exports = function(RED) {
    "use strict";
	const Hubspot = require('hubspot')
	var hubspot = ''

    var apiKey = ''; 

	/****************************** Hubspot CONFIG *******************************/
    function HubspotApiKey(config){
    	var node = this;
    	RED.nodes.createNode(node, config);
	
    			try {
					apiKey = config.apiKey;
    				hubspot = new Hubspot({ apiKey: apiKey })

				} catch(err) {
					console.log(err)
					//node.error(err);
				}
    }
    RED.nodes.registerType("hubspot-app",HubspotApiKey);

/* *************************************************** HUBSPOT CONTACT *****************************************************/
	
	/****************************** HubspotContact Get *******************************/
	async function getAllContacts(){
		return new Promise (async resolve => {

			if(apiKey && apiKey!=''){
				var contacts = await hubspot.contacts.get()
				resolve(contacts)
			}
		})
		
	}

	/****************************** HubspotContact GetByEmail *******************************/
	async function getContactByEmail(msg,config){
		return new Promise (async resolve => {

			if(apiKey && apiKey!=''){
				hubspot.contacts.getByEmail(msg.payload).then(contact => {
					resolve(contact)
				}).catch(error => {
					resolve({error: true, message: error.message})
				})
			}
		})
		
	}

	/****************************** HubspotContact Create *******************************/
	async function createContact(msg,config){
		return new Promise (async resolve => {
			if(apiKey && apiKey!=''){
				var properties =[]
				if( msg.payload !== null && typeof msg.payload === 'object'){
					let obj = msg.payload
					for (var prop in obj) {
						properties.push({ "property": `${prop}`, "value": `${obj[prop]}` })
					}
				}
				else{
						var obj = config.proprieties
					for (var prop in obj) {
						if(`${obj[prop]}` !== ''){
				        	properties.push({ "property": `${prop}`, "value": `${obj[prop]}` })
				    	}
					}
				}				
					var contactObj = {"properties" : properties}
					var contact = await hubspot.contacts.create(contactObj)
					resolve(contact)

			}
		})
		
	}

	/****************************** HubspotContact Update *******************************/
	async function updateContact(msg,config){
		return new Promise (async resolve => {
			if(apiKey && apiKey!=''){
				var contact = await getContactByEmail(msg,config)
				if(contact.error){
					resolve(contact)
					return;
				}
				var contactUp = await hubspot.contacts.update(contact.vid, msg.data)
				resolve(contactUp)

			}
		})
		
	}

	/****************************** HubspotContact delete *******************************/
	async function deleteContact(msg,config){
		return new Promise (async resolve => {
			if(apiKey && apiKey!=''){
				
				var contact = await getContactByEmail(msg,config)
				if(contact.error){
					resolve(contact)
					return;
				}
				var contactDel = await hubspot.contacts.delete(contact.vid)
				resolve(contactDel)

			}
		})
		
	}
	

	/****************************** HubspotContact *******************************/
   function HubspotContact(config) {

        var node = this;
		RED.nodes.createNode(node, config);		
		node.on("input", async function(msg){
				switch(config.operation){
					case "get" : 
						msg.payload = await getAllContacts();
						break;
					case "getByEmail" : 
						msg.payload = await getContactByEmail(msg,config);
						break;
					case "create" : 
						msg.payload = await createContact(msg,config);
						break;
					case "update" : 
						msg.payload = await updateContact(msg,config);
						break;
					case "delete" : 
						msg.payload = await deleteContact(msg,config);
						break;
				}			
			node.send(msg);	
        });		

    }
	RED.nodes.registerType("Hubspot Contact",HubspotContact);


/* *************************************************** HUBSPOT ENGAGEMENT *****************************************************/

	/****************************** HubspotEngagement Get *******************************/
	async function getAllEngagements(){
		return new Promise (async resolve => {

			if(apiKey && apiKey!=''){
				var engagements = await hubspot.engagements.get()
				resolve(engagements)
			}
		})
		
	}

	/****************************** HubspotEngagement getRecentlyModified *******************************/
	async function getRecentlyModified(msg,config){
		return new Promise (async resolve => {

			if(apiKey && apiKey!=''){
				var opts = {}
				if(config.count !== "" ){
					opts['count'] = config.count
				}
				if(config.date !== ""){
					let timestamp = Math.round(new Date(config.date+"T"+config.time+"Z").getTime())
					opts['since'] = timestamp
				}
				if(config.offset !== ""){
					opts['offset'] = config.offset
				}
			
				var engagements = await hubspot.engagements.getRecentlyModified(opts)
				resolve(engagements)
			}
		})
		
	}

	/****************************** HubspotEngagement Create *******************************/
	async function createEngagement(msg,config){
		return new Promise (async resolve => {
			if(apiKey && apiKey!=''){
				var engObj = {}
				if( msg.payload !== null && typeof msg.payload === 'object'){
					let obj = msg.payload
					engObj = {
					 "engagement": {
					        "active": true,
						        "ownerId": obj.ownerId,
						        "type": obj.type,
						    },
						    "metadata": {
					           	"body": obj.body,
							    "subject": obj.subject,
							    "status": obj.status,
							    "forObjectType": "CONTACT"
						    }
						}	
					
				}
				else{
					engObj = {
					 "engagement": {
					        "active": true,
						        "ownerId": config.uid,
						        "type": "TASK",
						    },
						    /*"associations": {
						        "contactIds": [2],
						        "companyIds": [ ],
						        "dealIds": [ ],
						        "ownerIds": [ ]
						    },
						    "attachments": [
						        {
						            "id": 4241968539
						        }
						    ],*/
						    "metadata": {
					           	"body": config.body,
							    "subject": config.subject,
							    "status": config.status,
							    "forObjectType": "CONTACT"
						    }
						}				
					}
				}			
					var engagement = await hubspot.engagements.create(engObj)
					resolve(engagement)
		})
		
	}

	/****************************** HubspotEngagement getCallDispositions *******************************/
	/*async function getCallDispositions(){
		return new Promise (async resolve => {
			if(apiKey && apiKey!=''){
				var engagements = await hubspot.engagements.getCallDispositions()
				resolve(engagements)

			}
		})
		
	}*/

	/****************************** HubspotEngagement delete *******************************/
	/*async function deleteEngagement(msg,config){
		return new Promise (async resolve => {
			if(apiKey && apiKey!=''){
				
				var contact = await getEngagementByEmail(msg,config)
				var contactDel = await hubspot.contacts.delete(contact.vid)
				resolve(contactDel)

			}
		})
		
	} */
	

	/****************************** HubspotEngagement *******************************/
   function HubspotEngagement(config) {

        var node = this;
		RED.nodes.createNode(node, config);		
		node.on("input", async function(msg){
				switch(config.operation){
					case "get" : 
						msg.payload = await getAllEngagements();
						break;
					case "getRecentlyModified" : 
						msg.payload = await getRecentlyModified(msg,config);
						break;
					case "create" : 
						msg.payload = await createEngagement(msg,config);
						break;
					/*case "getCallDispositions" : 
						msg.payload = await getCallDispositions();
						break;*/
				}			
			node.send(msg);	
        });		

    }
	RED.nodes.registerType("Hubspot Engagement",HubspotEngagement);
};