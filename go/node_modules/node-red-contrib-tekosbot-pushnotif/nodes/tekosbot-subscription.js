"use strict";

var request = require('request');
const appName = process.env.CHAT_APP_NAME;
const appUri = process.env.CHAT_APP_URI;
const appImage = process.env.CHAT_APP_IMAGE;
const CryptoJS = require('crypto-js');

module.exports = function (RED) {

  function GetSubscriptions(n) {
    RED.nodes.createNode(this, n);
    var node = this;
    var url = "https://api.tekos.co/v1/sm/push/list/uids/"+appName;
    var method = "GET";
    var nodeFollowRedirects = true;

    this.on("input", function (msg) {
      node.status({
        fill: "blue",
        shape: "dot",
        text: "requesting..."
      });
      
      var opts = {
        method: method,
        url: url,
        timeout: 120000,
        followRedirect: nodeFollowRedirects,
        headers: {},
        encoding: null,
      };
      opts.headers['content-type'] = "application/json";
      opts.headers.accept = "application/json, text/plain;q=0.9, */*;q=0.8";

      request(opts, function (error, response, body) {
        node.status({});
        if (error) {
          if (error.code === 'ETIMEDOUT') {
            node.error(RED._("common.notification.errors.no-response"), msg);
            setTimeout(function () {
              node.status({
                fill: "red",
                shape: "ring",
                text: "common.notification.errors.no-response"
              });
            }, 10);
          } else {
            node.error(error, msg);
            msg.payload = error.toString() + " : " + url;
            msg.statusCode = error.code;
            node.send(msg);
            node.status({
              fill: "red",
              shape: "ring",
              text: error.code
            });
          }
        } else {
          msg.payload = JSON.parse(body.toString('utf8'));
          node.send(msg);
        }
      });
    });
  }


  function addSubscription(n) {
    RED.nodes.createNode(this, n);
    var node = this;
    var url = "https://api.tekos.co/v1/sm/push/subscribe/"+appName+"/";
    var method = "POST";
    var nodeFollowRedirects = true;

    this.on("input", function (msg) {
      node.status({
        fill: "blue",
        shape: "dot",
        text: "requesting..."
      });
      
      var opts = {
        method: method,
        url: url+msg.uid,
        timeout: 120000,
        followRedirect: nodeFollowRedirects,
        headers: {},
        encoding: null,
      };

      // ADD this on post request
    //   opts.body = JSON.stringify(msg.payload);
      if (opts.headers['content-type'] == null) {
        opts.headers['content-type'] = "application/json";
      }

       opts.headers.accept = "application/json, text/plain;q=0.9, */*;q=0.8";

      request(opts, function (error, response, body) {
        node.status({});
        if (error) {
          if (error.code === 'ETIMEDOUT') {
            node.error(RED._("common.notification.errors.no-response"), msg);
            setTimeout(function () {
              node.status({
                fill: "red",
                shape: "ring",
                text: "common.notification.errors.no-response"
              });
            }, 10);
          } else {
            node.error(error, msg);
            msg.payload = error.toString() + " : " + url;
            msg.statusCode = error.code;
            node.send(msg);
            node.status({
              fill: "red",
              shape: "ring",
              text: error.code
            });
          }
        } else {
          msg.payload = JSON.parse(body.toString('utf8'));
          node.send(msg);
        }
      });
    });
  }

  function validSecretKey(skey=""){
    let bytes  = CryptoJS.AES.decrypt(skey, process.env.DECRYPT_KEY);
    let appUriName = bytes.toString(CryptoJS.enc.Utf8);
    if(appUriName == appName){
      return true
    }
    return false
  }
  

  function notify(n) {
    RED.nodes.createNode(this, n);
    var node = this;
    // send application name
    var url = "https://api.tekos.co/v1/sm/push/notify/"+appName;
    var method = "POST";

    this.on("input", function (msg) {

      if(!validSecretKey(n.secretKey)){
        node.status({
          fill: "red",
          shape: "dot",
          text: "not valid key"
        });
        console.log("not validSecretKey ...")
        return;
      }

      var notificationMessage = msg.message || n.message 
      node.status({
        fill: "blue",
        shape: "dot",
        text: "requesting..."
      });
      
      var opts = {
        method: method,
        url: url,
        timeout: 120000,
        followRedirect: true,
        headers: {},
        encoding: null,
      };

      // ADD this on post request
      opts.body = JSON.stringify({
          uids: msg.uids,
          notification: {
              title: appName,
              image: appImage,
              body: notificationMessage,
              data: {
                appName: appName,
                uri: appUri,
                startText: msg.startText
              }
          }
      })
    //   opts.body = JSON.stringify(msg.payload);
      if (opts.headers['content-type'] == null) {
        opts.headers['content-type'] = "application/json";
      }

       opts.headers.accept = "application/json, text/plain;q=0.9, */*;q=0.8";

      request(opts, function (error, response, body) {
        node.status({});
        if (error) {
          if (error.code === 'ETIMEDOUT') {
            node.error(RED._("common.notification.errors.no-response"), msg);
            setTimeout(function () {
              node.status({
                fill: "red",
                shape: "ring",
                text: "common.notification.errors.no-response"
              });
            }, 10);
          } else {
            node.error(error, msg);
            msg.payload = error.toString() + " : " + url;
            msg.statusCode = error.code;
            node.send(msg);
            node.status({
              fill: "red",
              shape: "ring",
              text: error.code
            });
          }
        } else {
          msg.payload = JSON.parse(body.toString('utf8')); 
          node.send(msg);
        }
      });
    });
  }





  RED.nodes.registerType("get-subscriptions", GetSubscriptions);
  RED.nodes.registerType("add-subscription", addSubscription);
  RED.nodes.registerType("tekos-notify", notify);
};