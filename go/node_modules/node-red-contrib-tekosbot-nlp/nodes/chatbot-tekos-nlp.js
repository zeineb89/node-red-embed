"use strict";

var request = require('request');
var mustache = require("mustache");

module.exports = function (RED) {

  function HTTPRequest(n) {
    RED.nodes.createNode(this, n);
    var node = this;
    var nodeUrl = n.url;
    var option = n.option;
    //var msgContent = n.msg;
    //var action = n.action;
    var nluUrl = nodeUrl+"/conversations/"+uid+"/"+option;
    var nodeFollowRedirects = n["follow-redirects"];
    var isTemplatedUrl = (nluUrl || "").indexOf("{{") != -1;
   // var isTemplatedMessage = (msgContent || "").indexOf("{{") != -1;
    var nodeMethod = "POST";
    var flow = this.context().flow;
    if (n.tls) {
      var tlsNode = RED.nodes.getNode(n.tls);
    }
    this.ret = n.ret || "txt";
    if (RED.settings.httpRequestTimeout) {
      this.reqTimeout = parseInt(RED.settings.httpRequestTimeout) || 120000;
    } else {
      this.reqTimeout = 120000;
    }

      var uid = n.uid;
    this.on("input", function (msg) {
      var token = n.token || flow.get('token');
      var uid = '';
      if(msg.uid){
        uid = msg.uid;
      }else uid = Math.random().toString(36).substring(7);

      var newMsg = '';
      if (msg.payload.text){
        if (msg.payload.text[0].length >1)
          {
            newMsg = msg.payload.text[0];
          }
        else 
          {
            newMsg = msg.payload.text;
          }
      }
      var preRequestTimestamp = process.hrtime();
      node.status({
        fill: "blue",
        shape: "dot",
        text: "requesting"
      });
      if (token != null){
            nluUrl= nodeUrl+"/conversations/"+uid+"/"+option+"?token="+token;

          }else{
            nluUrl= nodeUrl+"/conversations/"+uid+"/"+option;
      }
      // console.log("Nluuuu tokeen",nluUrl);
      var url = nluUrl || msg.url;
      if (msg.url && nluUrl && (nluUrl !== msg.url)) { // revert change below when warning is finally removed
        node.warn(RED._("Warning: msg properties can no longer override set node properties. See bit.ly/nr-override-msg-props"));
      }
      if (isTemplatedUrl) {

        nluUrl = mustache.render(nluUrl, msg);
      }
      /*if (isTemplatedMessage) {
        newMsg = mustache.render(msgContent, msg.payload);
        console.log("/////////////////////////////////////////newMsg")
        console.log(newMsg)
      }*/
      

      if (!nluUrl) {
        node.error(RED._("No url specified"), msg);
        node.status({
          fill: "red",
          shape: "ring",
          text: (RED._("No url specified"))
        });
        return;
      }
      // url must start http:// or https:// so assume http:// if not set
      if (!((nluUrl.indexOf("http://") === 0) || (nluUrl.indexOf("https://") === 0))) {
        if (tlsNode) {
          nluUrl = "https://" + nluUrl;
        } else {
          nluUrl = "http://" + nluUrl;
        }
      }

      var method = nodeMethod.toUpperCase() || "GET";
      if (msg.method && n.method && (n.method !== "use")) { // warn if override option not set
        node.warn(RED._("Warning: msg properties can no longer override set node properties. See bit.ly/nr-override-msg-props"));
      }
      if (msg.method && n.method && (n.method === "use")) {
        method = msg.method.toUpperCase(); // use the msg parameter
      }
      var opts = {
        method: method,
        url: nluUrl,
        timeout: node.reqTimeout,
        followRedirect: nodeFollowRedirects,
        headers: {'token': token},
        encoding: null,
      };

      if (msg.headers) {
        for (var v in msg.headers) {
          if (msg.headers.hasOwnProperty(v)) {
            var name = v.toLowerCase();
            if (name !== "content-type" && name !== "content-length") {
              // only normalise the known headers used later in this
              // function. Otherwise leave them alone.
              name = v;
            }
            opts.headers[name] = msg.headers[v];
          }
        }
      }

      if (method == "POST") {

        if (opts.headers['content-type'] == 'application/x-www-form-urlencoded') {
          opts.form = msg.payload;
        } else {
          
            // msg.payload
            let query = {query: newMsg }
            var executed_action = '';

            if (option == "continue"){
              if(msg.executed_action){
                executed_action = msg.executed_action;
                
              }else {
                executed_action = {executed_action: '',  "events": []};
              }
              opts.body = JSON.stringify(executed_action);
              opts.headers = {}
            }else{
              executed_action = ''
              opts.body = JSON.stringify(query);
            }

            
            if (opts.headers['content-type'] == null) {
              opts.headers['content-type'] = "application/json";
            }
         }
        
      }

      if (node.ret === "obj") {
        opts.headers.accept = "application/json, text/plain;q=0.9, */*;q=0.8";
      }

      if (this.credentials && this.credentials.user) {
        opts.auth = {
          user: this.credentials.user,
          pass: this.credentials.password,
          sendImmediately: false
        };
      }

      if (tlsNode) {
        tlsNode.addTLSOptions(opts);
      }

      request(opts, function (error, response, body) {
        node.status({});
        if (error) {
          if (error.code === 'ETIMEDOUT') {
            node.error(RED._("no response from server"), msg);
            setTimeout(function () {
              node.status({
                fill: "red",
                shape: "ring",
                text: "no response from server"
              });
            }, 10);
          } else {
            node.error(error, msg);
            msg.payload = error.toString() + " : " + url;
            msg.statusCode = error.code;
            node.send(msg);
            node.status({
              fill: "red",
              shape: "ring",
              text: error.code
            });
            console.log("msssg"+msg);
          }
        } else {
          msg.payload = body;
          msg.headers = response.headers;
          msg.statusCode = response.statusCode;
          if (node.metric()) {
            // Calculate request time
            var diff = process.hrtime(preRequestTimestamp);
            var ms = diff[0] * 1e3 + diff[1] * 1e-6;
            var metricRequestDurationMillis = ms.toFixed(3);
            node.metric("duration.millis", msg, metricRequestDurationMillis);
            if (response.connection && response.connection.bytesRead) {
              node.metric("size.bytes", msg, response.connection.bytesRead);
            }
          }

          if (node.ret !== "bin") {
            msg.payload = msg.payload.toString('utf8'); // txt

            if (node.ret === "obj") {
              try { msg.payload = JSON.parse(msg.payload); } // obj
              catch(e) { 
                //node.warn(RED._("JSON parse error")); 
                console.log("JSON parse error");
              }
            }
          }

          msg.executed_action = {executed_action: msg.payload.next_action,  "events": []}
          node.send(msg);
        }
      });
    });
  }

  RED.nodes.registerType("tekos-nlp", HTTPRequest, {
    credentials: {
      user: {
        type: "text"
      },
      password: {
        type: "password"
      }
    }
  });
};